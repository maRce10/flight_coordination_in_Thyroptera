---
title: <center><font size="6"><b>Inquiry calling rate in group and solo flights</b></font></center>
subtitle: <center><font size="4"><b>Group flight coordination in Thyroptera</b></font></center>
author: <center><font size="4"><a href="http://marceloarayasalas.weebly.com/">Marcelo Araya-Salas, PhD</a> & <a href="https://www.batcr.com/">Gloriana Chaverri, PhD</a></font></center>
date: <center>`r format(Sys.Date(), "%d-%m-%Y")`</center>
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 3
    df_print: kable
    toc_float:
      collapsed: yes
      smooth_scroll: yes
editor_options: 
  chunk_output_type: console
---

# next steps


# Load packages

```{r packages, message = FALSE, warning = FALSE, echo = TRUE, eval = TRUE}

## add 'developer' to packages to be installed from github
x <- c("data.table", "lubridate", "devtools", "maRce10/warbleR", "readxl", "ranger", "caret", "e1071", "pbapply", "viridis", "ggplot2", "DT", "kableExtra", "rlang", "Sim.DiffProc", "soundgen", "brms", "ggrepel", "posterior", "ggridges", "tidybayes", "purrr" #, "markovchain", "igraph", "TraMineR", "spgs"
       )

aa <- lapply(x, function(y) {
  
  # get pakage name
  pkg <- strsplit(y, "/")[[1]]
  pkg <- pkg[length(pkg)]
  
  # check if installed, if not then install 
  if (!pkg %in% installed.packages()[,"Package"])  {

      if (grepl("/", y))  devtools::install_github(y, force = TRUE) else
    install.packages(y) 
    }

  # load package
  a <- try(require(pkg, character.only = T), silent = T)

  if (!a) remove.packages(pkg)
  })

```

# Functions and global parameters
```{r functions and parameters, eval = TRUE, echo = TRUE}

warbleR_options(wl = 300, parallel = 1, bp = "frange", fast = TRUE, threshold = 15, ovlp = 20)

opts_knit$set(root.dir = "..")


theme_set(theme_classic(base_size = 24))

# set evaluation false
opts_chunk$set( fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE, tidy = FALSE)


cols <- viridis(10, alpha = 0.7)

# print results brms models
summary_brm_model <- function(x, gsub.pattern = NULL, gsub.replacement = NULL){
  
  summ <- summary(x)$fixed
  fit <- x$fit  
  betas <- grep("^b_", names(fit@sim$samples[[1]]), value = TRUE)  
  hdis <- t(sapply(betas, function(y)   hdi(fit@sim$samples[[1]][[y]]))
)
  summ_table <- data.frame(summ, hdis, iterations = attr(fit, "stan_args")[[1]]$iter, chains = length(attr(fit, "stan_args")))
  summ_table <- summ_table[rownames(summ_table) != "Intercept", c("Estimate", "Rhat", "Bulk_ESS", "l.95..CI", "u.95..CI", "iterations", "chains")]
  
  summ_table <- as.data.frame(summ_table)  
  summ_table$Rhat <- round(summ_table$Rhat, digits = 3)  
  summ_table$CI_low <- round(unlist(summ_table$l.95..CI), digits = 3)  
  summ_table$CI_high <- round(unlist(summ_table$u.95..CI), digits = 3)  
  summ_table$l.95..CI <- summ_table$u.95..CI <- NULL
  
    out <- lapply(betas, function(y)  data.frame(variable = y, value = sort(fit@sim$samples[[1]][[y]], decreasing = FALSE)))
  
  posteriors <- do.call(rbind, out)
  posteriors <- posteriors[posteriors$variable != "b_Intercept", ]
  
  if (!is.null(gsub.pattern) & !is.null(gsub.replacement))
    posteriors$variable <- gsub(pattern = gsub.pattern, replacement = gsub.replacement, posteriors$variable)
  
   gg <- ggplot(data = posteriors, aes(y = variable, x = value, fill = stat(quantile))) + 
  geom_density_ridges_gradient(quantile_lines = TRUE, quantile_fun = HDInterval::hdi,  vline_linetype = 2) + 
  theme_classic() + 
     xlim(range(c(min(summ_table[ , "CI_low"]), max(summ_table[ , "CI_high"])), 0)) +
  geom_vline(xintercept = 0, col = "red") + 
  scale_fill_manual(values = c("transparent", "lightblue", "transparent"), guide = "none") + ggtitle(x$formula)

  if (!is.null(gsub.pattern) & !is.null(gsub.replacement))
    rownames(summ_table) <- gsub(pattern = gsub.pattern, replacement = gsub.replacement, rownames(summ_table))
   
  summ_table$Rhat <- ifelse(summ_table$Rhat > 1.05, cell_spec(summ_table$Rhat, "html", color ="white", background = "red", bold = TRUE,  font_size = 12),  cell_spec(summ_table$Rhat, "html"))
  
  signif <- summ_table[,"CI_low"] * summ_table[,"CI_high"] > 0
  
  df1 <- kbl(summ_table, row.names = TRUE, escape = FALSE, format = "html", digits = 3)
    
  df1 <- row_spec(kable_input = df1,row =  which(summ_table$CI_low * summ_table$CI_high > 0), background = adjustcolor(cols[9], alpha.f = 0.3))

  df1 <- kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)
  
  print(df1)
  
  print(gg)

  }
  
```

# Read data
```{r read data, eval = TRUE}

clls <- readRDS("./data/processed/curated_extended_selection_table_inquiry_calls_2020_&_2021.RDS")

sub_clls <- clls[!duplicated(clls$org.sound.files), ]
sub_clls$file.duration <- sub_clls$sound.file.samples / (sub_clls$sample.rate * 1000)

metadat <- read.csv("./data/processed/metadata_inquiry_calls_2020_&_2021.csv", stringsAsFactors = FALSE)

caps <- as.data.frame(read_excel("./data/raw/Proyecto MPI enero 2020_2.xlsx", sheet = "Capturas"))

# read acoustic parameter data
acous_param_l <- readRDS("./data/processed/acoustic_parameters_all_groups_specific_warbler_acoustic_measurements_curated_data_2020_&_2021.RDS")

# read as RDS
agg_pred <- readRDS("./data/processed/predicted_individual_in_group_flights_2020_&_2021.RDS")

# read diagnostics
diagnostics <- readRDS("./data/processed/random_forests_diagnostics_solo_flight.RDS")

```

```{r results on predicted group flights, eval = TRUE}

# remove groups with individuals with no solo flight

diagnostics$all_with_solo <- sapply(1:nrow(diagnostics), function(x) 
{
    Y <- acous_param_l[[diagnostics$group[x]]]
  Y$sound.files <- sapply(Y$sound.files, function(x) strsplit(x, ".wav")[[1]][1])
  Y$year.audio <- sapply(Y$sound.files, function(x) sub_clls$year.audio[gsub(".wav", "", sub_clls$org.sound.files) == x][1])
    
  indivs <- strsplit(na.omit(Y$indiv[Y$year.audio == diagnostics$group_flight_files[x]])[1], split = "\\|")[[1]]

  call_per_indiv <- sapply(indivs, function(y) sum(clls$Individuo == y & clls$Experimento == "vuelo solo"))
  
  if (any(call_per_indiv == 0)) return("missing solo")  else 
    return("OK")
  }
)

diagnostics <- diagnostics[diagnostics$all_with_solo == "OK", ]

agg_pred <-agg_pred[agg_pred$group %in% diagnostics$group, ]

# get summary by group
summary_by_group_list <- lapply(unique(agg_pred$group), function(x) {
    # print(x)
  Y <- agg_pred[agg_pred$group == x, ]

#total number of calls above lowest group threshold for true positives
  above_threshold_calls <- sum(Y$max_prob > diagnostics$min_prob_threshold[diagnostics$group == x])

#proportion of calls
  prop_above_calls <- above_threshold_calls / nrow(Y)

  return(data.frame(group = x, experiment = diagnostics$experiment[diagnostics$group == x], total_calls = nrow(Y), above_threshold_calls = above_threshold_calls, prop_above_calls, n_individuals = diagnostics$n_indiv[diagnostics$group == x]))
  
})

# calls per individual and group
calls_by_indiv_group <- aggregate(sound.files ~ group + pred_indiv, agg_pred, length)

names(calls_by_indiv_group) <- c("Group", "Individual_ID", "Number_of_calls")

calls_by_indiv_group <- calls_by_indiv_group[order(calls_by_indiv_group$Group), ]

write.csv(calls_by_indiv_group, "./data/processed/calls_by_indiv_group.csv", row.names = FALSE)

summary_by_group <- do.call(rbind, summary_by_group_list)

groups_by_cat <- aggregate(group ~ experiment, summary_by_group, FUN = function(x) length(unique(x)))

#print pretty table
df3 <- knitr::kable(groups_by_cat, row.names = FALSE, escape = FALSE, format = "html", digits = 2)

kable_styling(df3, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 18)
```

Group count by number of individuals and experiment
```{r results on predicted group flights by experiment 2, eval = TRUE}
groups_by_cat_n <- as.data.frame.matrix(table(summary_by_group$experiment, summary_by_group$n_individuals))

#print pretty table
df4 <- knitr::kable(groups_by_cat_n, row.names = TRUE, escape = FALSE, format = "html", digits = 2)

kable_styling(df4, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 18)

```

---

# Call rate

```{r individual vs group call, eval = FALSE, echo = TRUE, fig.width = 12, fig.height = 8}

# get group and solo call counts per individual, call rate in call/min
call_rate_list <- pblapply(1:nrow(diagnostics), function(x){

  Y <- acous_param_l[[diagnostics$group[x]]]
  Y$sound.files <- sapply(Y$sound.files, function(x) strsplit(x, ".wav")[[1]][1])
  Y$year.audio <- sapply(Y$sound.files, function(x) sub_clls$year.audio[gsub(".wav", "", sub_clls$org.sound.files) == x][1])
  
  indivs_in_group <- strsplit(Y$indiv[Y$year.audio == diagnostics$group_flight_files[x]], split = "\\|")[[1]] 
  
  calls_per_sound_file_list <- lapply(na.omit(c(indivs_in_group, "group")), function(y){ 
    
      if (y != "group"){
      tab <- table(Y$year.audio[Y$indiv == y])
      if (length(tab) == 0) {tab <- 0
      names(tab) <- y}
      } else{
        tab <- sum(Y$year.audio == diagnostics$group_flight_files[x], na.rm = TRUE)
    names(tab) <- diagnostics$group_flight_files[x]
        }
    
    df <- data.frame(group = diagnostics$group[x], experiment = diagnostics$experiment[x], year.audio = names(tab), indiv = y, calls = as.vector(tab), flight.time = sapply(names(tab), USE.NAMES = FALSE, function(x) (round(as.numeric(metadat$Tiempo.de.vuelo[metadat$year.audio == x][1]) * 60 / 0.04166667))), file.duration = sapply(names(tab), function(x) (sub_clls$file.duration[sub_clls$year.audio == x][1])))
    
    return(df)
    }
  )
  
  calls_per_sound_file <- do.call(rbind, calls_per_sound_file_list)
  
  calls_per_sound_file$rate <- calls_per_sound_file$calls / calls_per_sound_file$file.duration * 60 # calls 

  return(calls_per_sound_file)
    })

call_rate_by_group <- do.call(rbind, call_rate_list)

rownames(call_rate_by_group) <- 1:nrow(call_rate_by_group)

#  add call rate to those missing
call_rate_by_group$rate <- ifelse(!is.na(call_rate_by_group$rate), call_rate_by_group$rate, call_rate_by_group$calls / call_rate_by_group$flight.time)

# add sex
call_rate_by_group$sex <- sapply(call_rate_by_group$indiv, function(x) if(x != "group") na.exclude(caps$Sexo[caps$Murci == x])[1] else NA, USE.NAMES = FALSE)

call_rate_by_group$sex <- ifelse(call_rate_by_group$sex == "m", "Male", "Female")

# add age
call_rate_by_group$age <- sapply(call_rate_by_group$indiv, function(x) if(x != "group") na.exclude(caps$Edad[caps$Murci == x])[1] else NA, USE.NAMES = FALSE)

call_rate_by_group$age <- ifelse(call_rate_by_group$age == "sa", "Sub-adult", "Adult")

# reproductive stage
call_rate_by_group$reprod.stg <- sapply(call_rate_by_group$indiv, function(x) if(x != "group") na.exclude(caps$`Estado reproductivo`[caps$Murci == x])[1] else NA, USE.NAMES = FALSE)

call_rate_by_group$reprod.stg[call_rate_by_group$reprod.stg == "p?"] <- "Pregnant"
call_rate_by_group$reprod.stg[call_rate_by_group$reprod.stg == "ne"] <- "Inactive"

call_rate_by_group$group.size <-sapply(call_rate_by_group$group, function(x) diagnostics$n_indiv[diagnostics$group == x])

# order levels
call_rate_by_group$experiment <- factor(call_rate_by_group$experiment, levels = c("regular", "mixed"))

call_rate_by_group$type <- factor(ifelse(call_rate_by_group$indiv == "group", "group", "solo"), levels = c("solo", "group"))

saveRDS(call_rate_by_group, "./data/processed/call_rate_by_group.RDS")

```

```{r calling rate per individual solo vs group, eval = FALSE, echo = TRUE, fig.width = 12, fig.height = 8}

# get group and solo call counts per individual, call rate in call/min
call_rate_indiv_list <- pblapply(1:nrow(diagnostics), function(x){

  # print(x)
  Y <- acous_param_l[[diagnostics$group[x]]]
  
  Y$pred.id <- NA
  # add id for group flights
  Y$pred.id[Y$experiment != "vuelo solo"] <- sapply(Y$sound.files[Y$experiment != "vuelo solo"], function(x) agg_pred$pred_indiv[agg_pred$sound.files == x])
  
  Y$sound.files <- sapply(Y$sound.files, function(x) strsplit(x, ".wav")[[1]][1])
  Y$year.audio <- sapply(Y$sound.files, function(x) sub_clls$year.audio[gsub(".wav", "", sub_clls$org.sound.files) == x][1])
  
  indivs_in_group <- na.omit(strsplit(Y$indiv[Y$year.audio == diagnostics$group_flight_files[x]], split = "\\|")[[1]]) 
  
  rate_indiv_list <- lapply(indivs_in_group, function(y){ 
    # print(y)
    year.audio.group <- na.omit(unique(Y$year.audio[Y$experiment != "vuelo solo"]))
    year.audio.solo <- na.omit(unique(Y$year.audio[Y$indiv == y & Y$experiment == "vuelo solo"]))
    
    flight.time.group <-  round(as.numeric(metadat$Tiempo.de.vuelo[metadat$year.audio == year.audio.group][1]) * 60 / 0.04166667)
  
    flight.time.solo <- sapply(year.audio.solo, function(w) round(as.numeric(metadat$Tiempo.de.vuelo[metadat$year.audio == w][1]) * 60 / 0.04166667)
)  
    file.duration.group <- sub_clls$file.duration[sub_clls$year.audio == year.audio.group][1]
    file.duration.solo <- sapply(year.audio.solo, function(w) sub_clls$file.duration[sub_clls$year.audio == w][1])
    
    calls.solo <- sapply(year.audio.solo, function(w) sum(Y$year.audio == w))
    calls.group <- sum(Y$year.audio == year.audio.group & Y$pred.id == y)
    
    df <- data.frame(indiv = y, group = diagnostics$group[x], size = length(indivs_in_group), experiment = diagnostics$experiment[x], type = c("group", "solo"), year.audio = c(year.audio.group, paste(year.audio.solo, collapse = "/")), calls = c(calls.group, sum(calls.solo)), flight.time = c(flight.time.group, sum(flight.time.solo)), file.duration = c(file.duration.group, sum(file.duration.solo)))
    
    return(df)
    }
  )
  
  rate_indiv <- do.call(rbind, rate_indiv_list)
  
  rate_indiv$rate <- rate_indiv$calls / rate_indiv$file.duration * 60 # calls 

  return(rate_indiv)
    })

call_rate_indiv <- do.call(rbind, call_rate_indiv_list)

rownames(call_rate_indiv) <- 1:nrow(call_rate_indiv)

#  add call rate to those missing
call_rate_indiv$rate <- ifelse(!is.na(call_rate_indiv$rate), call_rate_indiv$rate, call_rate_indiv$calls / call_rate_indiv$flight.time)

# add sex
call_rate_indiv$sex <- sapply(call_rate_indiv$indiv, function(x) if(x != "group") na.exclude(caps$Sexo[caps$Murci == x])[1] else NA, USE.NAMES = FALSE)

call_rate_indiv$sex <- ifelse(call_rate_indiv$sex == "m", "Male", "Female")

# add age
call_rate_indiv$age <- sapply(call_rate_indiv$indiv, function(x) if(x != "group") na.exclude(caps$Edad[caps$Murci == x])[1] else NA, USE.NAMES = FALSE)

call_rate_indiv$age <- ifelse(call_rate_indiv$age == "sa", "Sub-adult", "Adult")

# reproductive stage
call_rate_indiv$reprod.stg <- sapply(call_rate_indiv$indiv, function(x) if(x != "group") na.exclude(caps$`Estado reproductivo`[caps$Murci == x])[1] else NA, USE.NAMES = FALSE)

call_rate_indiv$reprod.stg[call_rate_indiv$reprod.stg == "p?"] <- "Pregnant"
call_rate_indiv$reprod.stg[call_rate_indiv$reprod.stg == "ne"] <- "Inactive"

call_rate_indiv$group.size <-sapply(call_rate_indiv$group, function(x) diagnostics$n_indiv[diagnostics$group == x])

# order levels
call_rate_indiv$experiment <- factor(call_rate_indiv$experiment, levels = c("regular", "mixed"))

call_rate_indiv$type <- factor(ifelse(call_rate_indiv$type == "group", "group", "solo"), levels = c("solo", "group"))

saveRDS(call_rate_indiv, "./data/processed/call_rate_by_individual.RDS")

```

```{r individual vs group call plot, eval = TRUE, echo = TRUE, fig.width = 12, fig.height = 8}

call_rate_by_group <- readRDS("./data/processed/call_rate_by_group.RDS")
call_rate_indiv <- readRDS("./data/processed/call_rate_by_individual.RDS")
call_rate_by_group <- call_rate_by_group[call_rate_by_group$type != "solo", ]
call_rate_by_group$type <- "overall.group"

call_rate_indiv$type <- as.character(call_rate_indiv$type)
call_rate_indiv$type[call_rate_indiv$type == "group"] <- "indiv.group" 

call_rate <- rbind(call_rate_by_group[, intersect(names(call_rate_by_group), names(call_rate_indiv))
], call_rate_indiv[, intersect(names(call_rate_by_group), names(call_rate_indiv))
])

# aggregate for plot
agg_rate <- aggregate(rate ~ experiment + type + group.size, data = call_rate, FUN = mean)

agg_rate$sd <- aggregate(rate ~ experiment + type + group.size, data = call_rate, FUN = sd)$rate

agg_rate$type <- factor(agg_rate$type, levels = c("solo", "indiv.group", "overall.group"))

# ggplot(agg_rate[agg_rate$group.size < 6, ], aes(x = type, y = rate)) + 
#   geom_point(color = viridis(10)[3], size = 2) +
#     geom_errorbar(aes(ymin = rate - sd, ymax = rate + sd), color = viridis(10)[3], width=.1, lwd = 1.1) +
#    geom_hline(yintercept = mean(call_rate$rate[call_rate$type == "solo"], na.rm = TRUE), lty = 2, alpha = 0.5) + 
#   labs(x = "Flight", y = "Call rate (calls / min)") + 
#   facet_grid(group.size ~ experiment) + 
#     theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r call rate per individual solo vs group lines plot, eval = TRUE, echo = TRUE, fig.width = 12, fig.height = 8}

# aggregate for plot
agg_rate_indiv <- aggregate(rate ~ experiment + type + group.size + indiv, data = call_rate_indiv, FUN = mean)

agg_rate_indiv$sd <- aggregate(rate ~ experiment + type + group.size + indiv, data = call_rate_indiv, FUN = sd)$rate

agg_rate_indiv <- agg_rate_indiv[agg_rate_indiv$indiv != "group", ]

mixed_ids <- unique(agg_rate_indiv$indiv[agg_rate_indiv$experiment == "mixed"])

mixed_l <- lapply(mixed_ids, function(x) {
  
  X <- agg_rate_indiv[agg_rate_indiv$indiv == x, ]
  X <- X[X$experiment == "mixed" | X$type == "solo", ]
  
  if (sum(X$experiment == "mixed") > 1)
    X <- X[X$group.size == max(X$group.size[X$experiment == "mixed"]) | X$type == "solo",]
  
  if (nrow(X) == 1)
    X <- X[vector(), ]
    
  return(X)
  })

mixed <- do.call(rbind, mixed_l)

mixed$experiment <- "mixed"

# regular
regular_ids <- unique(agg_rate_indiv$indiv[agg_rate_indiv$experiment == "regular"])

regular_l <- lapply(regular_ids, function(x) {
  
  X <- agg_rate_indiv[agg_rate_indiv$indiv == x, ]
  X <- X[X$experiment == "regular" | X$type == "solo", ]
  
  if (sum(X$experiment == "regular") > 1)
    X <- X[X$group.size == max(X$group.size[X$experiment == "regular"]) | X$type == "solo",]
  
  if (nrow(X) == 1)
    X <- X[vector(), ]
    
  return(X)
  })

regular <- do.call(rbind, regular_l)

regular$experiment <- "regular"

sub_agg <- rbind(mixed, regular)

sub_agg$experiment_f <- factor(ifelse(sub_agg$experiment == "regular", "Regular", "Artificial"), levels = c("Regular", "Artificial"))

sub_agg$type_f <- factor(ifelse(sub_agg$type == "solo", "Solo", "In group"), levels = c("Solo", "In group"))

# individual plot solo vs individual in group
ggplot(sub_agg, aes(x = type_f, y = rate, group = indiv, color = group.size)) + 
  geom_line() +
  geom_point(size = 2) +
  scale_color_viridis_c(alpha = 0.8) +
  labs(x = "Flight", y = "Call rate (calls/s)", color = "Group\nsize") + 
  facet_grid( ~ experiment_f) +
   theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## Individual call rate in solo and group flight

```{r individual call rate stats, eval = FALSE}

call_rate_indiv <- call_rate_indiv[!is.na(call_rate_indiv$rate) & call_rate_indiv$rate > 0, ]

call_rate_indiv$experiment.type <- ifelse(call_rate_indiv$type == "solo", "solo", paste(call_rate_indiv$experiment, call_rate_indiv$type, sep = "-"))

call_rate_indiv$experiment.type <- gsub("mixed-indiv.group", "artificial.group", call_rate_indiv$experiment.type)
call_rate_indiv$experiment.type <- gsub("regular-indiv.group", "real.group", call_rate_indiv$experiment.type)

call_rate_indiv$experiment.type <- factor(call_rate_indiv$experiment.type, levels = c("solo", "real.group", "artificial.group")) 

# mean centering group size
call_rate_indiv$group.size <- call_rate_indiv$group.size - mean(call_rate_indiv$group.size)

chains <- 3
iter <- 5000

model_formulas <- c("rate ~ experiment.type + (1 | indiv)", "rate ~ experiment.type + experiment.type:group.size + (1 | indiv)",  "rate ~ 1 + (1 | indiv)", "rate ~ experiment.type + (experiment.type | indiv)", "rate ~ experiment.type + experiment.type:group.size + (experiment.type | indiv)",  "rate ~ 1 + (experiment.type | indiv)")

brms_models <- lapply(model_formulas, function(x){

  mod <- brm(
          formula = x,
          iter = iter,
          thin = 1,
          data = call_rate_indiv,
          family = lognormal(),
          silent = 2,
          chains = chains,
          cores = chains
          )
  
  mod <- add_criterion(mod, c("loo"))

  return(mod)
  })

names(brms_models) <- model_formulas

saveRDS(brms_models, "./data/processed/individual_call_rate_solo_vs_group_models.RDS")

```

```{r individual call rate results, eval = TRUE, results = "asis"}

brms_models <- readRDS("./data/processed/individual_call_rate_solo_vs_group_models.RDS")

cat(paste(length(brms_models),"models evaluated:\n"))

for(i in names(brms_models))
  cat(paste("-  ", i, "\n"))

comp_mods <- loo_compare(brms_models[[1]], brms_models[[2]], brms_models[[3]], brms_models[[4]], brms_models[[5]], brms_models[[6]], model_names = names(brms_models))


  df1 <- kbl(comp_mods, row.names = TRUE, escape = FALSE, format = "html", digits = 3)

  cat("Compare models:")
  
 kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

cat("Best model:\n")
cat(paste("-  ", rownames(comp_mods)[1], "\n"))

# best model
if (!grepl("1 +", rownames(comp_mods)[1], fixed = TRUE))
summary_brm_model(brms_models[[rownames(comp_mods)[1]]], gsub.pattern = "experiment.type", gsub.replacement = "solo_vs_")

```

&nbsp;

<div class="alert alert-info">

### Takeaways

- Individuals call at lower rates during group flight (both real and artificial) compared to solo flight
- Rates also decreases in artificial groups as a function of group size

</div>

&nbsp;

## Individual call rate vs overall group call rate

```{r call rate per group solo vs group lines plot, eval = TRUE, echo = TRUE, fig.width = 12, fig.height = 8}

call_rate_by_group <- readRDS("./data/processed/call_rate_by_group.RDS")

call_rate_by_group$experiment.type <- ifelse(call_rate_by_group$type == "solo", "solo", paste(call_rate_by_group$experiment, call_rate_by_group$type, sep = "-"))

call_rate_by_group$experiment.type <- gsub("mixed.group", "artificial.group", call_rate_by_group$experiment.type)
call_rate_by_group$experiment.type <- gsub("regular.group", "real.group", call_rate_by_group$experiment.type)

call_rate_by_group$experiment.type <- factor(call_rate_by_group$experiment.type, levels = c("solo", "real.group", "artificial.group")) 

# aggregate for plot
agg_rate_group <- aggregate(rate ~ experiment + type + group.size + group, data = call_rate_by_group, FUN = mean)

agg_rate_group$sd <- aggregate(rate ~ experiment + type + group.size + group, data = call_rate_by_group, FUN = sd)$rate

agg_rate_group <- agg_rate_group[agg_rate_group$type != "indiv.group", ]

mixed_ids <- unique(agg_rate_group$group[agg_rate_group$experiment == "mixed"])

mixed_l <- lapply(mixed_ids, function(x) {
  
  X <- agg_rate_group[agg_rate_group$group == x, ]
  X <- X[X$experiment == "mixed" | X$type == "solo", ]
  
  if (sum(X$experiment == "mixed") > 1)
    X <- X[X$group.size == max(X$group.size[X$experiment == "mixed"]) | X$type == "solo",]
  
  if (nrow(X) == 1)
    X <- X[vector(), ]
    
  return(X)
  })

mixed <- do.call(rbind, mixed_l)

mixed$experiment <- "mixed"

# regular
regular_ids <- unique(agg_rate_group$group[agg_rate_group$experiment == "regular"])

regular_l <- lapply(regular_ids, function(x) {
  
  X <- agg_rate_group[agg_rate_group$group == x, ]
  X <- X[X$experiment == "regular" | X$type == "solo", ]
  
  if (sum(X$experiment == "regular") > 1)
    X <- X[X$group.size == max(X$group.size[X$experiment == "regular"]) | X$type == "solo",]
  
  if (nrow(X) == 1)
    X <- X[vector(), ]
    
  return(X)
  })

regular <- do.call(rbind, regular_l)

regular$experiment <- "regular"

sub_agg <- rbind(mixed, regular)

sub_agg$experiment_f <- factor(ifelse(sub_agg$experiment == "regular", "Regular", "Artificial"), levels = c("Regular", "Artificial"))

sub_agg$type_f <- factor(ifelse(sub_agg$type == "solo", "Solo", "Overall group"), levels = c("Solo", "Overall group"))

# individual plot solo vs individual in group
ggplot(sub_agg, aes(x = type_f, y = rate, group = group, color = group.size)) + 
  geom_line() +
  geom_point(size = 2) +
  scale_color_viridis_c(alpha = 0.8) +
  labs(x = "Flight", y = "Call rate (calls/s)", color = "Group\nsize") + 
  facet_grid( ~ experiment_f) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# in the same scale than he one  above

# ggplot(sub_agg, aes(x = type_f, y = rate, group = group, color = group.size)) + 
#   geom_line() +
#   geom_point(size = 2) +
#   scale_color_viridis_c(alpha = 0.8) +
#   labs(x = "Flight", y = "Call rate (calls/s)", color = "Group\nsize") + 
#   facet_grid( ~ experiment_f) +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
#   ylim(c(0, 210))

```

```{r individual vs group call rate stats, eval = FALSE}

call_rate_by_group <- readRDS("./data/processed/call_rate_by_group.RDS")

call_rate_by_group$experiment.type <- ifelse(call_rate_by_group$type == "solo", "solo", paste(call_rate_by_group$experiment, call_rate_by_group$type, sep = "-"))

call_rate_by_group$experiment.type <- gsub("mixed.group", "artificial.group", call_rate_by_group$experiment.type)
call_rate_by_group$experiment.type <- gsub("regular.group", "real.group", call_rate_by_group$experiment.type)

call_rate_by_group$experiment.type <- factor(call_rate_by_group$experiment.type, levels = c("solo", "real.group", "artificial.group")) 

# mean centering group size
call_rate_by_group$group.size <- call_rate_by_group$group.size - mean(call_rate_by_group$group.size)

chains <- 3
iter <- 5000

model_formulas <- c("rate ~ experiment.type + (1 | group)", "rate ~ experiment.type + experiment.type:group.size + (1 | group)",  "rate ~ 1 + (1 | group)")

brms_models <- lapply(model_formulas, function(x){

  mod <- brm(
          formula = x,
          iter = iter,
          thin = 1,
          data = call_rate_by_group,
          family = lognormal(),
          silent = 2,
          chains = chains,
          cores = chains
          )
  
  mod <- add_criterion(mod, c("loo"))

  return(mod)
  })

names(brms_models) <- model_formulas

saveRDS(brms_models, "./data/processed/individual_vs_group_call_rate_models.RDS")

```

```{r individual vs group call rate results, eval = TRUE, results = "asis"}

brms_models <- readRDS("./data/processed/individual_vs_group_call_rate_models.RDS")

cat(paste(length(brms_models), "models evaluated:\n"))

for(i in names(brms_models))
  cat(paste("-  ", i, "\n"))

comp_mods <- loo_compare(brms_models[[1]], brms_models[[2]], brms_models[[3]], model_names = names(brms_models))


  df1 <- kbl(comp_mods, row.names = TRUE, escape = FALSE, format = "html", digits = 3)

  cat("Compare models:")
  
 kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

# cat("Best model:\n")
# cat(paste("-  ", rownames(comp_mods)[1], "\n"))
# 
# # best model
# if (!grepl("1 +", rownames(comp_mods)[1], fixed = TRUE))
# summary_brm_model(brms_models[[rownames(comp_mods)[1]]], gsub.pattern = "experiment.type", gsub.replacement = "solo_vs_")

```

*The best model did not outperforme the null (intercept only) model*

&nbsp;

<div class="alert alert-info">

### Takeaways

- No difference in overall call rate between solo and group flights (both real and artificial)

</div>

&nbsp;

# Gaps 

## Individual gaps in solo vs group flights
```{r gaps per individual solo vs group, eval = FALSE, echo = TRUE, fig.width = 12, fig.height = 8}


seltab <- attributes(clls)$check.results
seltab$year.audio <- clls$year.audio
seltab <- seltab[!is.na(seltab$sound.files), ]
seltab$type <- sapply(seltab$year.audio, function(x) metadat$Experimento[metadat$year.audio == x][1])
seltab$group <- sapply(seltab$year.audio, function(x) metadat$Grupo[metadat$year.audio == x][1])
seltab <- seltab[!is.na(seltab$group), ]
seltab$type <-ifelse(grepl("solo", seltab$type), "solo", "group")
seltab$indiv <- sapply(1:nrow(seltab), function(x) if (seltab$type[x] == "solo") metadat$Individuo[metadat$year.audio == seltab$year.audio[x]] else "group")
seltab$start <- seltab$orig.start
seltab$end <- seltab$orig.end

# get group and solo call counts per individual, call rate in call/min
gaps_indiv_list <- pblapply(1:nrow(diagnostics), function(x){

  # print(x)
  # get indivs
  sound.files <- acous_param_l[[diagnostics$group[x]]]$sound.files
  
    Y <- seltab[seltab$sound.files %in% sound.files, ]

  # add id for group flights
  Y$pred.id <- NA
  Y$pred.id[Y$type == "group"] <- sapply(Y$sound.files[Y$type == "group"], function(x) agg_pred$pred_indiv[agg_pred$sound.files == x])

  Y <- Y[order(Y$orig.sound.files, Y$start), ]
    
  gaps_indiv_list <- lapply(unique(Y$indiv), function(y){ 
# print(y)
    if (y != "group"){
      W <- Y[Y$indiv == y, ]
      W$sound.files <- W$orig.sound.files
      
      gaps.solo <- data.frame(group =  diagnostics$group[x], indiv = y, experiment =  diagnostics$experiment[x], type = "solo", gaps = if (nrow(W) > 0) na.omit(gaps(W, pb = FALSE)$gaps) else NA)
    
      Z <- Y[Y$pred.id == y & !is.na(Y$pred.id), ]
      Z$sound.files <- Z$orig.sound.files 
      group.gaps <- if (nrow(Z) > 0) na.omit(gaps(Z, pb = FALSE)$gaps) else NA
      gaps.group <- data.frame(group =  diagnostics$group[x], indiv = y, experiment =  diagnostics$experiment[x], type = "indiv.group", gaps =  if (length(group.gaps) > 0) group.gaps else NA)
       
    gaps_data <- rbind(gaps.group, gaps.solo)  
    
    } else {
      Q <- Y[Y$type == "group", ]
      Q$sound.files <- Q$orig.sound.files
    gaps_data <- data.frame(group =  diagnostics$group[x], indiv = y, experiment = diagnostics$experiment[x], type = "overall.group", gaps =  na.omit(gaps(Q, pb = FALSE)$gaps))
      
return(gaps_data)
    }
  })
  gaps_indiv <- do.call(rbind, gaps_indiv_list)
  gaps_indiv$group.size <- diagnostics$n_indiv[x]
  
  
    return(gaps_indiv)
    }
  )
  
gaps_indiv <- do.call(rbind, gaps_indiv_list)
  
# add sex
gaps_indiv$sex <- sapply(gaps_indiv$indiv, function(x) if(x != "group") na.exclude(caps$Sexo[caps$Murci == x])[1] else NA, USE.NAMES = FALSE)

gaps_indiv$sex <- ifelse(gaps_indiv$sex == "m", "Male", "Female")

# add age
gaps_indiv$age <- sapply(gaps_indiv$indiv, function(x) if(x != "group") na.exclude(caps$Edad[caps$Murci == x])[1] else NA, USE.NAMES = FALSE)

gaps_indiv$age <- ifelse(gaps_indiv$age == "sa", "Sub-adult", "Adult")

# reproductive stage
gaps_indiv$reprod.stg <- sapply(gaps_indiv$indiv, function(x) if(x != "group") na.exclude(caps$`Estado reproductivo`[caps$Murci == x])[1] else NA, USE.NAMES = FALSE)

gaps_indiv$reprod.stg[gaps_indiv$reprod.stg == "p?"] <- "Pregnant"
gaps_indiv$reprod.stg[gaps_indiv$reprod.stg == "ne"] <- "Inactive"

gaps_indiv$group.size <-sapply(gaps_indiv$group, function(x) diagnostics$n_indiv[diagnostics$group == x])

# order levels
gaps_indiv$experiment <- factor(gaps_indiv$experiment, levels = c("Regular", "Artificial"))

gaps_indiv$experiment.type <- ifelse(gaps_indiv$type == "solo", "solo", paste(gaps_indiv$experiment, gaps_indiv$type, sep = "-"))


# #find individuals with repeated solo data
# indivs_2_sets <- sapply(unique(gaps_indiv$indiv), function(x) length(unique(gaps_indiv$group[gaps_indiv$indiv == x & gaps_indiv$type == "solo"])))
# 
# # remove those
# indivs_2_sets <- names(indivs_2_sets)[indivs_2_sets > 1]
# indivs_2_sets <- indivs_2_sets[indivs_2_sets != "group"]
# 
# gaps_indiv_filter_list <- lapply(unique(gaps_indiv$indiv), function(x){
# 
#   Y <- gaps_indiv[gaps_indiv$indiv == x, ]
#   
#   if(x %in% indivs_2_sets){
#     Y <- Y[Y$group == unique(Y$group)[1] & Y$type == "solo" | Y$type == "indiv.group",]
#     
#   }
#   
#   return(Y)
#   
# })

# gaps_indiv_filter <- do.call(rbind, gaps_indiv_filter_list)
# 
# # all have 1
# all(sapply(unique(gaps_indiv_filter$indiv), function(x) length(unique(gaps_indiv_filter$group[gaps_indiv_filter$indiv == x & gaps_indiv_filter$type == "solo"]))) <= 1)

 saveRDS(gaps_indiv, "./data/processed/gaps_by_individual.RDS")

```

```{r gaps per individual solo vs group plot, eval = TRUE, echo = TRUE, fig.width = 12, fig.height = 8}
gaps_indiv <- readRDS("./data/processed/gaps_by_individual.RDS")


# aggregate for plot
agg_gaps <- aggregate(gaps ~ experiment + type + group.size, data = gaps_indiv, FUN = mean)

agg_gaps$sd <- aggregate(gaps ~ experiment + type + group.size, data = gaps_indiv, FUN = sd)$gaps

# ggplot(agg_gaps[agg_gaps$group.size < 6, ], aes(x = type, y = gaps)) + 
#   geom_point(color = viridis(10)[3], size = 2) +
#     geom_errorbar(aes(ymin = gaps - sd, ymax = gaps + sd), color = viridis(10)[3], width=.1, lwd = 1.1) +
#    geom_hline(yintercept = mean(gaps_indiv$gaps[gaps_indiv$type == "solo"], na.rm = TRUE), lty = 2, alpha = 0.5) + 
#   labs(x = "Flight", y = "Gap duration (s)") + 
#   facet_grid(group.size ~ experiment) +
#    theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r gaps per individual solo vs group lines plot, eval = TRUE, echo = TRUE, fig.width = 12, fig.height = 8}

# aggregate for plot
agg_gaps_indiv <- aggregate(gaps ~ experiment + type + group.size + indiv, data = gaps_indiv, FUN = mean)

agg_gaps_indiv$sd <- aggregate(gaps ~ experiment + type + group.size + indiv, data = gaps_indiv, FUN = sd)$gaps

agg_gaps_indiv <- agg_gaps_indiv[agg_gaps_indiv$indiv != "group", ]

mixed_ids <- unique(agg_gaps_indiv$indiv[agg_gaps_indiv$experiment == "mixed"])

mixed_l <- lapply(mixed_ids, function(x) {
  
  X <- agg_gaps_indiv[agg_gaps_indiv$indiv == x, ]
  X <- X[X$experiment == "mixed" | X$type == "solo", ]
  
  if (sum(X$experiment == "mixed") > 1)
    X <- X[X$group.size == max(X$group.size[X$experiment == "mixed"]) | X$type == "solo",]
  
  if (nrow(X) == 1)
    X <- X[vector(), ]
    
  return(X)
  })

mixed <- do.call(rbind, mixed_l)

mixed$experiment <- "mixed"

# regular
regular_ids <- unique(agg_gaps_indiv$indiv[agg_gaps_indiv$experiment == "regular"])

regular_l <- lapply(regular_ids, function(x) {
  
  X <- agg_gaps_indiv[agg_gaps_indiv$indiv == x, ]
  X <- X[X$experiment == "regular" | X$type == "solo", ]
  
  if (sum(X$experiment == "regular") > 1)
    X <- X[X$group.size == max(X$group.size[X$experiment == "regular"]) | X$type == "solo",]
  
  if (nrow(X) == 1)
    X <- X[vector(), ]
    
  return(X)
  })

regular <- do.call(rbind, regular_l)

regular$experiment <- "regular"

sub_agg <- rbind(mixed, regular)

sub_agg$experiment_f <- factor(ifelse(sub_agg$experiment == "regular", "Regular", "Artificial"), levels = c("Regular", "Artificial"))

sub_agg$type_f <- factor(ifelse(sub_agg$type == "solo", "Solo", "In group"), levels = c("Solo", "In group"))

# individual plot solo vs individual in group
ggplot(sub_agg, aes(x = type_f, y = gaps, group = indiv, color = group.size)) + 
  geom_line() +
  geom_point(size = 2) +
  scale_color_viridis_c(alpha = 0.8) +
  labs(x = "Flight", y = "Gap duration (s)", color = "Group\nsize") + 
  facet_grid( ~ experiment_f) +
   theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r gaps per individual solo vs group stats, eval = FALSE}

chains <- 3
iter <- 10000

sub_gaps_indiv <- gaps_indiv[gaps_indiv$type != "overall.group", ]

sub_gaps_indiv$experiment.type <- gsub("-indiv.group", "", sub_gaps_indiv$experiment.type)

sub_gaps_indiv$experiment.type <- gsub("mixed", "artificial.group", sub_gaps_indiv$experiment.type)
sub_gaps_indiv$experiment.type <- gsub("regular", "real.group", sub_gaps_indiv$experiment.type)

sub_gaps_indiv$experiment.type <- factor(sub_gaps_indiv$experiment.type, levels = c("solo", "real.group", "artificial.group")) 

# mean centering group size
sub_gaps_indiv$group.size <- sub_gaps_indiv$group.size - mean(sub_gaps_indiv$group.size)

model_formulas <- c("gaps ~ experiment.type + (1 | indiv)", "gaps ~ experiment.type + experiment.type:group.size + (1 | indiv)", "gaps ~ 1 + (1 | indiv)", "gaps ~ experiment.type + (experiment.type | indiv)", "gaps ~ experiment.type + experiment.type:group.size + (experiment.type | indiv)", "gaps ~ 1 + (experiment.type | indiv)")

brms_models <- lapply(model_formulas, function(x){

  mod <- brm(
          formula = x,
          iter = iter,
          thin = 1,
          data = sub_gaps_indiv,
          family = lognormal(),
          silent = 2,
          chains = chains,
          cores = chains
          )
  
  mod <- add_criterion(mod, c("loo"))

  return(mod)
  })

names(brms_models) <- model_formulas

saveRDS(brms_models, "./data/processed/individual_gaps_solo_vs_group_models.RDS")

```

```{r gaps per individual solo vs group results, eval = TRUE, results = "asis"}

brms_models <- readRDS("./data/processed/individual_gaps_solo_vs_group_models.RDS")

cat(paste(length(brms_models),"models evaluated:\n"))

for(i in names(brms_models))
  cat(paste("-  ", i, "\n"))

comp_mods <- loo_compare(brms_models[[1]], brms_models[[2]], brms_models[[3]], brms_models[[4]], brms_models[[5]], brms_models[[6]], model_names = names(brms_models))


df1 <- kbl(comp_mods, row.names = TRUE, escape = FALSE, format = "html", digits = 3)

  cat("Compare models:")
  
 kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

cat("Best model:\n")
cat(paste("-  ", rownames(comp_mods)[1], "\n"))

# best model
if (!grepl("1 +", rownames(comp_mods)[1], fixed = TRUE))
summary_brm_model(brms_models[[rownames(comp_mods)[1]]], gsub.pattern = "experiment.type", gsub.replacement = "solo_vs_")

# contrasts
cat("Compare artificial vs real group gaps:\n")
```

```{r gaps per individual solo vs group results contrasts, eval = TRUE}

contrasts <- c(one = "experiment.typeartificial.group - experiment.typereal.group = 0")
hypothesis(brms_models[[rownames(comp_mods)[1]]], contrasts)

```

```{r print best model, eval = FALSE}
brms_models[[rownames(comp_mods)[1]]]
```


```{r gaps per individual solo vs group random slope stats DEPRECATED, eval = FALSE}

chains <- 3
iter <- 10000

sub_gaps_indiv <- gaps_indiv[gaps_indiv$type != "overall.group", ]

sub_gaps_indiv$experiment.type <- gsub("-indiv.group", "", sub_gaps_indiv$experiment.type)

sub_gaps_indiv$experiment.type <- gsub("mixed", "artificial.group", sub_gaps_indiv$experiment.type)
sub_gaps_indiv$experiment.type <- gsub("regular", "real.group", sub_gaps_indiv$experiment.type)

sub_gaps_indiv$experiment.type <- factor(sub_gaps_indiv$experiment.type, levels = c("solo", "real.group", "artificial.group")) 

# mean centering group size
sub_gaps_indiv$group.size <- sub_gaps_indiv$group.size - mean(sub_gaps_indiv$group.size)

model_formulas <- c("gaps ~ experiment.type + (experiment.type | indiv)", "gaps ~ experiment.type + experiment.type:group.size + (experiment.type | indiv)", "gaps ~ experiment.type + group.size + (experiment.type | indiv)", "gaps ~ 1 + (experiment.type | indiv)")

brms_models <- lapply(model_formulas, function(x){

  mod <- brm(
          formula = x,
          iter = iter,
          thin = 1,
          data = sub_gaps_indiv,
          family = lognormal(),
          silent = 2,
          chains = chains,
          cores = chains
          )
  
  mod <- add_criterion(mod, c("loo"))

  return(mod)
  })

names(brms_models) <- model_formulas

saveRDS(brms_models, "./data/processed/individual_gaps_solo_vs_group_random_slope_models.RDS")

```

```{r gaps per individual solo vs group random slope results DEPRECATED, eval = FALSE, results = "asis"}

brms_models <- readRDS("./data/processed/individual_gaps_solo_vs_group_random_slope_models.RDS")

cat(paste(length(brms_models),"models evaluated:\n"))

for(i in names(brms_models))
  cat(paste("-  ", i, "\n"))

comp_mods <- loo_compare(brms_models[[1]], brms_models[[2]], brms_models[[3]], brms_models[[4]], model_names = names(brms_models))


  df1 <- kbl(comp_mods, row.names = TRUE, escape = FALSE, format = "html", digits = 3)

  cat("Compare models:")
  
 kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

cat("Best model:\n")
cat(paste("-  ", rownames(comp_mods)[1], "\n"))

# best model
if (!grepl("1 +", rownames(comp_mods)[1], fixed = TRUE))
summary_brm_model(brms_models[[rownames(comp_mods)[1]]], gsub.pattern = "experiment.type", gsub.replacement = "solo_vs_")
# 
# # contrasts
cat("Compare artificial vs real group gaps:\n")
```

```{r gaps per individual solo vs group random slope results contrasts DEPRECATED, eval = FALSE}

contrasts <- c(one = "experiment.typeartificial.group - experiment.typereal.group = 0")
hypothesis(brms_models[[rownames(comp_mods)[1]]], contrasts)

```

&nbsp;

<div class="alert alert-info">

### Takeaways

- Gaps in group flights (both mixed and regular groups) increases compare to solo flights but the magnitude of the response varies individually
- Group size also affects the magnitude of change in group flights 

</div>

&nbsp;

## Individual gaps vs overall group gaps

```{r gaps per group solo vs group lines plot, eval = TRUE, echo = TRUE, fig.width = 12, fig.height = 8}

# aggregate for plot
agg_gaps_group <- aggregate(gaps ~ experiment + type + group.size + group, data = gaps_indiv, FUN = mean)

agg_gaps_group$sd <- aggregate(gaps ~ experiment + type + group.size + group, data = gaps_indiv, FUN = sd)$gaps

agg_gaps_group <- agg_gaps_group[agg_gaps_group$type != "indiv.group", ]

mixed_ids <- unique(agg_gaps_group$group[agg_gaps_group$experiment == "mixed"])

mixed_l <- lapply(mixed_ids, function(x) {
  
  X <- agg_gaps_group[agg_gaps_group$group == x, ]
  X <- X[X$experiment == "mixed" | X$type == "solo", ]
  
  if (sum(X$experiment == "mixed") > 1)
    X <- X[X$group.size == max(X$group.size[X$experiment == "mixed"]) | X$type == "solo",]
  
  if (nrow(X) == 1)
    X <- X[vector(), ]
    
  return(X)
  })

mixed <- do.call(rbind, mixed_l)

mixed$experiment <- "mixed"

# regular
regular_ids <- unique(agg_gaps_group$group[agg_gaps_group$experiment == "regular"])

regular_l <- lapply(regular_ids, function(x) {
  
  X <- agg_gaps_group[agg_gaps_group$group == x, ]
  X <- X[X$experiment == "regular" | X$type == "solo", ]
  
  if (sum(X$experiment == "regular") > 1)
    X <- X[X$group.size == max(X$group.size[X$experiment == "regular"]) | X$type == "solo",]
  
  if (nrow(X) == 1)
    X <- X[vector(), ]
    
  return(X)
  })

regular <- do.call(rbind, regular_l)

regular$experiment <- "regular"

sub_agg <- rbind(mixed, regular)

sub_agg$experiment_f <- factor(ifelse(sub_agg$experiment == "regular", "Regular", "Artificial"), levels = c("Regular", "Artificial"))

sub_agg$type_f <- factor(ifelse(sub_agg$type == "solo", "Solo", "Overall group"), levels = c("Solo", "Overall group"))

# individual plot solo vs individual in group
ggplot(sub_agg, aes(x = type_f, y = gaps, group = group, color = group.size)) + 
  geom_line() +
  geom_point(size = 2) +
  scale_color_viridis_c(alpha = 0.8) +
  labs(x = "Flight", y = "Gap duration (s)", color = "Group\nsize") + 
  facet_grid( ~ experiment_f) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# in the same scale than he one  above

ggplot(sub_agg, aes(x = type_f, y = gaps, group = group, color = group.size)) + 
  geom_line() +
  geom_point(size = 2) +
  scale_color_viridis_c(alpha = 0.8) +
  labs(x = "Flight", y = "Gap duration (s)", color = "Group\nsize") + 
  facet_grid( ~ experiment_f) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  ylim(c(0, 210))

```

```{r gaps per group solo vs group stats, eval = FALSE}

chains <- 3
iter <- 10000

sub_gaps_indiv <- gaps_indiv[gaps_indiv$type != "indiv.group", ]

sub_gaps_indiv$experiment.type <- gsub("-overall.group", "", sub_gaps_indiv$experiment.type)

sub_gaps_indiv$experiment.type <- gsub("mixed", "artificial.group", sub_gaps_indiv$experiment.type)
sub_gaps_indiv$experiment.type <- gsub("regular", "real.group", sub_gaps_indiv$experiment.type)

sub_gaps_indiv$experiment.type <- factor(sub_gaps_indiv$experiment.type, levels = c("solo", "real.group", "artificial.group")) 


model_formulas <- c("gaps ~ experiment.type + (1 | group)", "gaps ~ experiment.type + experiment.type:group.size + (1 | group)",  "gaps ~ 1 + (1 | group)")

brms_models <- lapply(model_formulas, function(x){

  mod <- brm(
          formula = x,
          iter = iter,
          thin = 1,
          data = sub_gaps_indiv,
          family = lognormal(),
          silent = 2,
          chains = chains,
          cores = chains
          )
  
  mod <- add_criterion(mod, c("loo"))

  return(mod)
  })

names(brms_models) <- model_formulas

saveRDS(brms_models, "./data/processed/group_gaps_solo_vs_group_models.RDS")

```

```{r gaps per group solo vs group results, eval = TRUE, results = "asis"}

brms_models <- readRDS("./data/processed/group_gaps_solo_vs_group_models.RDS")

cat(paste(length(brms_models),"models evaluated:\n"))

for(i in names(brms_models))
  cat(paste("-  ", i, "\n"))

comp_mods <- loo_compare(brms_models[[1]], brms_models[[2]], brms_models[[3]], model_names = names(brms_models))


  df1 <- kbl(comp_mods, row.names = TRUE, escape = FALSE, format = "html", digits = 3)

  cat("Compare models:")
  
 kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

cat("Best model:\n")
cat(paste("-  ", rownames(comp_mods)[1], "\n"))

# best model
if (!grepl("1 +", rownames(comp_mods)[1], fixed = TRUE))
summary_brm_model(brms_models[[rownames(comp_mods)[1]]], gsub.pattern = "experiment.type", gsub.replacement = "solo_vs_")

# contrasts
cat("Compare artificial vs real group gaps:\n")
```

```{r gaps per group solo vs group results contrasts, eval = TRUE}

contrasts <- c(one = "experiment.typeartificial.group - experiment.typereal.group = 0")
hypothesis(brms_models[[rownames(comp_mods)[1]]], contrasts)

```

&nbsp;

<div class="alert alert-info">

### Takeaways

- Gaps in artificial groups are longer than in solo flights (but not for real groups)
- Group size positively affects gap duration in both types of group flights

</div>

&nbsp;

```{r Compare gaps duration among sexes, eval = FALSE}

str(gaps_indiv)

indivs <- unique(gaps_indiv$indiv) 
indivs <- indivs[indivs != "group"]

gaps_indiv_sex_l <- lapply(indivs, function(x){
  
  X <- gaps_indiv[gaps_indiv$indiv == x, ]
  X <- X[X$type == "indiv.group", ]
  
  if(any(!is.na(X$sex)))
    X$sex <- X$sex[!is.na(X$sex)][1]
  
    if(any(!is.na(X$age)))
    X$age <- X$age[!is.na(X$age)][1]
 
     if(any(!is.na(X$reprod.stg)))
    X$reprod.stg <- X$reprod.stg[!is.na(X$reprod.stg)][1]
  
  X <- X[!is.na(X$sex), ]
  
  return(X)
  }
)

gaps_indiv_sex <- do.call(rbind, gaps_indiv_sex_l)

table(gaps_indiv_sex$sex, gaps_indiv_sex$experiment)

ggplot(gaps_indiv_sex, aes(x = sex, y = gaps)) + 
  geom_violin() + 
  facet_wrap(~ experiment) +
  theme_classic()

```

```{r DEPRECATED Calls location in group flight by individual, eval = F, fig.height= 8, fig.width= 12}

# read as RDS
agg_pred <- readRDS("./data/processed/predicted_individual_in_group_flights_2020_&_2021.RDS")

agg_pred$orig.sound.files <- paste0(sapply(agg_pred$sound.files, function(x) strsplit(x, ".wav")[[1]][1]), ".wav")

agg_pred$start <- sapply(agg_pred$sound.files, function(x) seltab$orig.start[seltab$sound.files == x])

agg_pred$end <- sapply(agg_pred$sound.files, function(x) seltab$orig.end[seltab$sound.files == x])

agg_pred$middle.time <- (agg_pred$start + agg_pred$end) / 2
 
agg_pred$abbr_indiv <- as.numeric(as.factor(agg_pred$pred_indiv))

agg_pred$group2 <- make.names(agg_pred$group)


agg_pred <- agg_pred[!duplicated(agg_pred[, c("group", "abbr_indiv", "start", "end")]), ]

agg_pred$row <- 1:nrow(agg_pred)

# this are repeated
# agg_pred[c(200, 206, 156, 219, 30, 31, 9, 60, 160, 225, 486, 435, 438, 432), ]

agg_pred <- agg_pred[-c(200, 156, 30, 9, 160, 435, 432), ]

out <- lapply(unique(agg_pred$group2), function(x) {
  
  print(x)
    Y <- agg_pred[agg_pred$group2 == x, ]

    # jpeg(filename = file.path("img/group_call_through_time", paste0(x, ".jpeg")), width = 480 * 3, height = 480 * 2, res = 200)

    par(mar = c(1, 0, 0, 0), mfrow = c(4, 1))  
  
  Y$middle.time <- Y$middle.time - min(Y$middle.time) 
  
  num.ind <- as.numeric(as.factor(Y$abbr_indiv))
  
  num.ind <- scale(num.ind, center = TRUE) 
    
  # sq <- seq(0, max(Y$middle.time), length.out = 5)
  sq <- seq(0, 120, length.out = 5)
  
  
  for (i in 1:(length(sq) - 1))  {
  
    plot(0, 0, col = "white", xlim = c(sq[i] - 0.05, sq[i + 1] + 0.05), ylim = range(num.ind) + c(-2, 2), bty = "u")
    
  points(x = Y$middle.time, y = num.ind, cex = 7, col = viridis(max(as.numeric(as.factor(Y$abbr_indiv))), alpha = 0.5)[as.numeric(as.factor(Y$abbr_indiv))], pch = 20)
    
    # text(x = Y$middle.time, y = num.ind + rnorm(nrow(Y), sd = 0.8), Y$row, cex = 0.6, col = "black")
  }
    
# dev.off()
  
})


```

```{r markovchain, eval = F}


lapply(unique(agg_pred$group), function(x) {
  
    Y <- agg_pred[agg_pred$group == x, ]

    mc <- markov.test(Y$abbr_indiv, type = "rank")
    
    return(mc)
}
)



seq <- simulateMarkovChain(5000, matrix(0.25, 4, 4), states=c("a","c","g","t"))

markov.test(seq)

rnd.seq <- sample(seq)
markov.test(rnd.seq)



sequenceMatr <- createSequenceMatrix(sequence, sanitize = FALSE)
mcFitMLE <- markovchainFit(data = sequence)

rnd.seq <- sample(sequence)

rnd <- createSequenceMatrix(rnd.seq, sanitize = FALSE)
mcFitMLE2 <- markovchainFit(data = rnd.seq)


mcFitBSP <- markovchainFit(data = sequence, method = "bootstrap", nboot = 5, name = "Bootstrap Mc")


sim.sq <- rep(c("a", "b", "c", "d"), 100)

verifyMarkovProperty(sim.sq)

sim.sq2 <- sample(c("a", "b", "c", "d"), size = 100, replace = TRUE)
verifyMarkovProperty(sim.sq2)


weatherStates <- c("sunny", "cloudy", "rain")

byRow <- TRUE

weatherMatrix <- matrix(data = c(0.70, 0.2, 0.1,0.3, 0.4, 0.3, 0.2, 0.45, 0.35), byrow = byRow, nrow = 3,dimnames = list(weatherStates, weatherStates))

mcWeather <- new("markovchain", states = weatherStates, byrow = byRow, transitionMatrix = weatherMatrix, name = "Weather")

mcIgraph <- as(mcWeather, "igraph")
plot(mcIgraph)

```


---

<font size="4">Session information</font>

```{r session info, echo=F, eval = TRUE}

sessionInfo()

```
