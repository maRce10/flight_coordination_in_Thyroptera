agg_cnt_sgmt$age <- ifelse(agg_cnt_sgmt$age == "sa", "Sub-adult", "Adult")
agg_cnt_sgmt$reprod.stg <- sapply(agg_cnt_sgmt$indiv, function(x) na.exclude(caps$`Estado reproductivo`[caps$Murci == x])[1], USE.NAMES = FALSE)
grp_cnt_sgmt <- aggregate(stand_count ~ sgmts + exp.type + indiv + group + sex + age, data = agg_cnt_sgmt[as.numeric(as.character(agg_cnt_sgmt$sgmts)) < 140, ], FUN = mean)
ggs <- lapply(unique(grp_cnt_sgmt$group), function(x){
grp <- grp_cnt_sgmt[grp_cnt_sgmt$group == x, ]
nind <- length(unique(grp$indiv)) - 1
gg <- ggplot(grp, aes(x = sgmts, y = stand_count, col = sex, group = indiv)) +
# scale_color_manual(values = c(rep(viridis(10)[8], nind), "black")) +
geom_point(size = 1) +
geom_line(aes(linetype = indiv)) +
scale_linetype_manual(values = c(rep(1, nind), 2)) +
labs(x = "Time (s)",y = "Call count  / group size") +
theme_classic() +
ggtitle(x) +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
gg <- if (x != 1)  gg + guides(color = FALSE, linetype = FALSE) else gg + guides(linetype = FALSE)
return(gg)
})
ggs[[1]]
grp_cnt_sgmt
unique(grp_cnt_sgmt$sex)
agg_cnt_sgmt$sex
grp_cnt_sgmt <- aggregate(stand_count ~ sgmts + exp.type + indiv + group + sex + age, data = agg_cnt_sgmt[as.numeric(as.character(agg_cnt_sgmt$sgmts)) < 140, ], FUN = mean)
grp_cnt_sgmt
agg_cnt_sgmt$indiv
agg_cnt_sgmt$sex[agg_cnt_sgmt$indiv == "group"]
agg_cnt_sgmt
View(agg_cnt_sgmt)
View(grp_cnt_sgmt)
unique(agg_cnt_sgmt$group)
unique(agg_cnt_sgmt$exp.type)
grp_cnt_sgmt
unique(agg_cnt_sgmt$exp.type)
table(grp_cnt_sgmt$exp.type)
grp_cnt_sgmt <- aggregate(stand_count ~ sgmts + exp.type + indiv + group, data = agg_cnt_sgmt[as.numeric(as.character(agg_cnt_sgmt$sgmts)) < 140, ], FUN = mean)
table(agg_cnt_sgmt$exp.type)
agg_cnt_sgmt
View(agg_cnt_sgmt)
grp_cnt_sgmt <- aggregate(stand_count ~ sgmts + exp.type + indiv + group, data = agg_cnt_sgmt, FUN = mean)
View(grp_cnt_sgmt)
ggs <- lapply(unique(grp_cnt_sgmt$group), function(x){
grp <- grp_cnt_sgmt[grp_cnt_sgmt$group == x, ]
nind <- length(unique(grp$indiv)) - 1
gg <- ggplot(grp, aes(x = sgmts, y = stand_count, col = sex, group = indiv)) +
# scale_color_manual(values = c(rep(viridis(10)[8], nind), "black")) +
geom_point(size = 1) +
geom_line(aes(linetype = indiv)) +
scale_linetype_manual(values = c(rep(1, nind), 2)) +
labs(x = "Time (s)",y = "Call count  / group size") +
theme_classic() +
ggtitle(x) +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
gg <- if (x != 1)  gg + guides(color = FALSE, linetype = FALSE) else gg + guides(linetype = FALSE)
return(gg)
})
ggs[[1]]
grp_cnt_sgmt <- aggregate(stand_count ~ sgmts + exp.type + indiv + group + sex, data = agg_cnt_sgmt, FUN = mean)
ggs <- lapply(unique(grp_cnt_sgmt$group), function(x){
grp <- grp_cnt_sgmt[grp_cnt_sgmt$group == x, ]
nind <- length(unique(grp$indiv)) - 1
gg <- ggplot(grp, aes(x = sgmts, y = stand_count, col = sex, group = indiv)) +
# scale_color_manual(values = c(rep(viridis(10)[8], nind), "black")) +
geom_point(size = 1) +
geom_line(aes(linetype = indiv)) +
scale_linetype_manual(values = c(rep(1, nind), 2)) +
labs(x = "Time (s)",y = "Call count  / group size") +
theme_classic() +
ggtitle(x) +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
gg <- if (x != 1)  gg + guides(color = FALSE, linetype = FALSE) else gg + guides(linetype = FALSE)
return(gg)
})
ggs[[1]]
table(metadat$Grupo, metadat$Experimento)
caps <- as.data.frame(read_excel("./data/raw/Proyecto MPI enero 2020_2.xlsx", sheet = "Capturas"))
agg_cnt_sgmt$sex <- sapply(agg_cnt_sgmt$indiv, function(x) na.exclude(caps$Sexo[caps$Murci == x])[1], USE.NAMES = FALSE)
agg_cnt_sgmt$sex <- ifelse(agg_cnt_sgmt$sex == "m", "Male", "Female")
agg_cnt_sgmt$sex[agg_cnt_sgmt$indiv == "group"] <- "group"
agg_cnt_sgmt$age <- sapply(agg_cnt_sgmt$indiv, function(x) na.exclude(caps$Edad[caps$Murci == x])[1], USE.NAMES = FALSE)
agg_cnt_sgmt$age <- ifelse(agg_cnt_sgmt$age == "sa", "Sub-adult", "Adult")
agg_cnt_sgmt$age[agg_cnt_sgmt$indiv == "group"] <- "group"
agg_cnt_sgmt$reprod.stg <- sapply(agg_cnt_sgmt$indiv, function(x) na.exclude(caps$`Estado reproductivo`[caps$Murci == x])[1], USE.NAMES = FALSE)
grp_cnt_sgmt <- aggregate(stand_count ~ sgmts + exp.type + indiv + group + sex, data = agg_cnt_sgmt, FUN = mean)
ggs <- lapply(unique(grp_cnt_sgmt$group), function(x){
grp <- grp_cnt_sgmt[grp_cnt_sgmt$group == x, ]
nind <- length(unique(grp$indiv)) - 1
gg <- ggplot(grp, aes(x = sgmts, y = stand_count, col = sex, group = indiv)) +
# scale_color_manual(values = c(rep(viridis(10)[8], nind), "black")) +
geom_point(size = 1) +
geom_line(aes(linetype = indiv)) +
scale_linetype_manual(values = c(rep(1, nind), 2)) +
labs(x = "Time (s)",y = "Call count  / group size") +
theme_classic() +
ggtitle(x) +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
gg <- #if (x != 1)  gg + guides(color = FALSE, linetype = FALSE) else
gg + guides(linetype = FALSE) +
theme(legend.position = c(0.2, 0.8))
return(gg)
})
plot_grid(plotlist = ggs, ncol = 2)
grp_cnt_sgmt2 <- aggregate(stand_count ~ sgmts + exp.type + indiv + group + age, data = agg_cnt_sgmt, FUN = mean)
ggs2 <- lapply(unique(grp_cnt_sgmt$group), function(x){
grp <- grp_cnt_sgmt[grp_cnt_sgmt$group == x, ]
nind <- length(unique(grp$indiv)) - 1
gg <- ggplot(grp, aes(x = sgmts, y = stand_count, col = age, group = indiv)) +
# scale_color_manual(values = c(rep(viridis(10)[8], nind), "black")) +
geom_point(size = 1) +
geom_line(aes(linetype = indiv)) +
scale_linetype_manual(values = c(rep(1, nind), 2)) +
labs(x = "Time (s)",y = "Call count  / group size") +
theme_classic() +
ggtitle(x) +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
gg <- #if (x != 1)  gg + guides(color = FALSE, linetype = FALSE) else
gg + guides(linetype = FALSE) +
theme(legend.position = c(0.2, 0.8))
return(gg)
})
ggs[[1]]
ggs2[[1]]
grp_cnt_sgmt2 <- aggregate(stand_count ~ sgmts + exp.type + indiv + group + age, data = agg_cnt_sgmt, FUN = mean)
ggs2 <- lapply(unique(grp_cnt_sgmt2$group), function(x){
grp <- grp_cnt_sgmt2[grp_cnt_sgmt2$group == x, ]
nind <- length(unique(grp$indiv)) - 1
gg <- ggplot(grp, aes(x = sgmts, y = stand_count, col = age, group = indiv)) +
# scale_color_manual(values = c(rep(viridis(10)[8], nind), "black")) +
geom_point(size = 1) +
geom_line(aes(linetype = indiv)) +
scale_linetype_manual(values = c(rep(1, nind), 2)) +
labs(x = "Time (s)",y = "Call count  / group size") +
theme_classic() +
ggtitle(x) +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
gg <- #if (x != 1)  gg + guides(color = FALSE, linetype = FALSE) else
gg + guides(linetype = FALSE) +
theme(legend.position = c(0.2, 0.8))
return(gg)
})
ggs2[[1]]
table(agg_cnt_sgmt$reprod.stg)
agg_cnt_sgmt$reprod.stg[agg_cnt_sgmt$reprod.stg == "ne"] <- "in"
grp_cnt_sgmt3 <- aggregate(stand_count ~ sgmts + exp.type + indiv + group + reprod.stg, data = agg_cnt_sgmt, FUN = mean)
grp_cnt_sgmt3 <- aggregate(stand_count ~ sgmts + exp.type + indiv + group + reprod.stg, data = agg_cnt_sgmt, FUN = mean)
ggs2 <- lapply(unique(grp_cnt_sgmt3$group), function(x){
grp <- grp_cnt_sgmt3[grp_cnt_sgmt3$group == x, ]
nind <- length(unique(grp$indiv)) - 1
gg <- ggplot(grp, aes(x = sgmts, y = stand_count, col = reprod.stg, group = indiv)) +
# scale_color_manual(values = c(rep(viridis(10)[8], nind), "black")) +
geom_point(size = 1) +
geom_line(aes(linetype = indiv)) +
scale_linetype_manual(values = c(rep(1, nind), 2)) +
labs(x = "Time (s)",y = "Call count  / group size") +
theme_classic() +
ggtitle(x) +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
gg <- #if (x != 1)  gg + guides(color = FALSE, linetype = FALSE) else
gg + guides(linetype = FALSE) +
theme(legend.position = c(0.2, 0.8))
return(gg)
})
ggs3 <- lapply(unique(grp_cnt_sgmt3$group), function(x){
grp <- grp_cnt_sgmt3[grp_cnt_sgmt3$group == x, ]
nind <- length(unique(grp$indiv)) - 1
gg <- ggplot(grp, aes(x = sgmts, y = stand_count, col = reprod.stg, group = indiv)) +
# scale_color_manual(values = c(rep(viridis(10)[8], nind), "black")) +
geom_point(size = 1) +
geom_line(aes(linetype = indiv)) +
scale_linetype_manual(values = c(rep(1, nind), 2)) +
labs(x = "Time (s)",y = "Call count  / group size") +
theme_classic() +
ggtitle(x) +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
gg <- #if (x != 1)  gg + guides(color = FALSE, linetype = FALSE) else
gg + guides(linetype = FALSE) +
theme(legend.position = c(0.2, 0.8))
return(gg)
})
ggs3[[1]]
library(rsconnect)
# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))
## add 'developer' to packages to be installed from github
x <- c("devtools", "maRce10/warbleR", "readxl", "ranger", "caret", "e1071", "pbapply")
aa <- lapply(x, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  devtools::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
try(require(pkg, character.only = T), silent = T)
})
warbleR_options(wav.path = "~/Dropbox/Recordings/flight_coordination_Thyroptera/converted_sound_files_90_kHz/", wl = 300, parallel = parallel::detectCores() - 4, bp = "frange", fast = F, threshold = 15, ovlp = 20)
opts_knit$set(root.dir = "..")
opts_chunk$set( fig.width = 8, fig.height = 3.5)
## add 'developer' to packages to be installed from github
x <- c("devtools", "maRce10/warbleR", "readxl", "ranger", "caret", "e1071", "pbapply")
aa <- lapply(x, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  devtools::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
try(require(pkg, character.only = T), silent = T)
})
packrat::snapshot()
packrat::clean()
packrat::snapshot()
## add 'developer' to packages to be installed from github
x <- c("devtools", "maRce10/warbleR", "readxl", "ranger", "caret", "e1071", "pbapply", "viridis", "ggplot2", "kableExtra")
aa <- lapply(x, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  devtools::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
try(require(pkg, character.only = T), silent = T)
})
warbleR_options(wl = 1100, parallel = parallel::detectCores() - 1, bp = "frange", fast = TRUE, threshold = 15, ovlp = 20)
opts_knit$set(root.dir = "..")
# set evaluation false
opts_chunk$set( fig.width = 6, fig.height = 3, eval = FALSE, warning = FALSE, message = FALSE, tidy = TRUE)
# number of trees in Random Forest models
num.trees <- 1000
# replicates in Random Forest replication
reps <- 50
# sensitivity cutoff
cutoff <- 0.85
# function to calculate classification random forest models with balanced sample sizes across categories
balanced_rf <- function(X, num.trees = 1000){
# get smallest n across individuals
min.n <- min(table(X$indiv))
# randomly get rows for equal n across indivs
sel_rows <-
sapply(unique(X$indiv), function(x)
sample(rownames(X)[X$indiv == x], min.n, replace = FALSE))
# subset to those rows
X <- X[as.numeric(c(sel_rows)),]
# convert to factor
X$indiv <- as.factor(X$indiv)
# run RF model spectral and cepstral parameters
rfm <-
ranger(
indiv ~ .,
data = X[,-c(1, 2)],
num.trees = num.trees,
importance = "impurity",
probability = TRUE
)
# get predicted individual from probs
pred_indiv <- apply(rfm$predictions, 1, function(x) colnames(rfm$predictions) [which.max(x)])
rfm$predictions <- data.frame(rfm$predictions, indiv = X$indiv, pred_indiv, sound.files = X$sound.files)
# remove X from start of names
names(rfm$predictions) <- gsub("^X", "", names(rfm$predictions))
return(rfm)
}
# function to calculate sensitivities at increasing RF class probabilities
sensitivity_fun <- function(X, thresholds = seq(0,1, by = 0.01)){
# get sensitivities for each group at very threshold
sensitiv_l <- lapply(X, function(x){
# extract prediction data.frame
Y <- x$aggregated_predictions
Y$max <- apply(Y[, sapply(Y, is.numeric)], 1, max)
# get sensitivity at different thresholds
sensi_l <- lapply(thresholds, function(y) data.frame(sensitivity = sum(Y$pred_indiv[Y$max >= y] == Y$actual_indiv[Y$max >= y])/ sum(Y$max >= y), n = sum(Y$max >= y) / nrow(Y)))
sensi <- do.call(rbind, sensi_l)
# add metadata
sensi$group <- x$group
sensi$n_indiv <- x$n_indiv
sensi$min_n <- x$min_n
sensi$n_calls <- nrow(Y) * sensi$n
return(sensi)
})
# put in a data frame
sensitivities <- as.data.frame(lapply(sensitiv_l, "[[", which(names(sensitiv_l[[1]]) == "sensitivity")))
# get minimum sensitivity at each probabilities
sensitivities$min.sensitivity <- apply(sensitivities, 1, min, na.rm = TRUE)
# get minimum sensitivity at each probabilities
sensitivities$mean.sensitivity <- apply(sensitivities, 1, mean, na.rm = TRUE)
# add thresholds to data frame
sensitivities$thresholds <- thresholds
# put in a data frame
sensitivities$n_calls <- rowSums(as.data.frame(lapply(sensitiv_l, "[[", which(names(sensitiv_l[[1]]) == "n_calls"))), na.rm = TRUE)
sensitivities$n_calls_prop <- sensitivities$n_calls / max(sensitivities$n_calls)
sensitivities <- sensitivities[!is.infinite(sensitivities$mean.sensitivity), ]
return(sensitivities)
}
# read ext sel tab calls
clls <- readRDS("./output/CALLS_fixed_detections_inquiry_calls.RDS")
# read metadata
metadat <- as.data.frame(read_excel("./data/raw/Proyecto MPI enero 2020_3.xlsx", sheet = "Experimento video coor vuelo"))
# nrow(metadat)
# remove video calibration
# metadat <- metadat[metadat$`tipo de video` !=  "calibracion de video", ]
metadat <- metadat[!is.na(metadat$Audio), ]
# get audio file name from sound files
clls$Audio <- sapply(clls$sound.files, function(x){
# split by _
spl <- strsplit(x, split = "_")[[1]]
# take 3rd
spl <- spl[grep(".wav$", spl)]
# remove .wav
spl <- gsub(".wav", "", spl)
# make it anumber
spl <- as.numeric(spl)
return(spl)
})
# anyNA(clls$Audio)
# nrow(clls)
clls <- clls[clls$Audio %in% metadat$Audio, ]
# add metadata to ext sel table
clls2 <- merge(clls, metadat[!duplicated(metadat$Audio), c("Audio", "tipo de video", "Experimento", "Grupo", "Individuo")])
clls <- fix_extended_selection_table(X = clls2, Y = clls)
# exclude those with obstacles
clls <- clls[clls$Experimento != "Búsqueda refugio con obstaculos", ]
clls$Individuo[clls$Experimento != "vuelo solo"] <- NA
remove.packages("rlang")
## add 'developer' to packages to be installed from github
x <- c("devtools", "maRce10/warbleR", "readxl", "ranger", "caret", "e1071", "pbapply", "viridis", "ggplot2", "kableExtra")
aa <- lapply(x, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  devtools::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
try(require(pkg, character.only = T), silent = T)
})
warbleR_options(wl = 1100, parallel = parallel::detectCores() - 1, bp = "frange", fast = TRUE, threshold = 15, ovlp = 20)
opts_knit$set(root.dir = "..")
# set evaluation false
opts_chunk$set( fig.width = 6, fig.height = 3, eval = FALSE, warning = FALSE, message = FALSE, tidy = TRUE)
# number of trees in Random Forest models
num.trees <- 1000
# replicates in Random Forest replication
reps <- 50
# sensitivity cutoff
cutoff <- 0.85
# function to calculate classification random forest models with balanced sample sizes across categories
balanced_rf <- function(X, num.trees = 1000){
# get smallest n across individuals
min.n <- min(table(X$indiv))
# randomly get rows for equal n across indivs
sel_rows <-
sapply(unique(X$indiv), function(x)
sample(rownames(X)[X$indiv == x], min.n, replace = FALSE))
# subset to those rows
X <- X[as.numeric(c(sel_rows)),]
# convert to factor
X$indiv <- as.factor(X$indiv)
# run RF model spectral and cepstral parameters
rfm <-
ranger(
indiv ~ .,
data = X[,-c(1, 2)],
num.trees = num.trees,
importance = "impurity",
probability = TRUE
)
# get predicted individual from probs
pred_indiv <- apply(rfm$predictions, 1, function(x) colnames(rfm$predictions) [which.max(x)])
rfm$predictions <- data.frame(rfm$predictions, indiv = X$indiv, pred_indiv, sound.files = X$sound.files)
# remove X from start of names
names(rfm$predictions) <- gsub("^X", "", names(rfm$predictions))
return(rfm)
}
# function to calculate sensitivities at increasing RF class probabilities
sensitivity_fun <- function(X, thresholds = seq(0,1, by = 0.01)){
# get sensitivities for each group at very threshold
sensitiv_l <- lapply(X, function(x){
# extract prediction data.frame
Y <- x$aggregated_predictions
Y$max <- apply(Y[, sapply(Y, is.numeric)], 1, max)
# get sensitivity at different thresholds
sensi_l <- lapply(thresholds, function(y) data.frame(sensitivity = sum(Y$pred_indiv[Y$max >= y] == Y$actual_indiv[Y$max >= y])/ sum(Y$max >= y), n = sum(Y$max >= y) / nrow(Y)))
sensi <- do.call(rbind, sensi_l)
# add metadata
sensi$group <- x$group
sensi$n_indiv <- x$n_indiv
sensi$min_n <- x$min_n
sensi$n_calls <- nrow(Y) * sensi$n
return(sensi)
})
# put in a data frame
sensitivities <- as.data.frame(lapply(sensitiv_l, "[[", which(names(sensitiv_l[[1]]) == "sensitivity")))
# get minimum sensitivity at each probabilities
sensitivities$min.sensitivity <- apply(sensitivities, 1, min, na.rm = TRUE)
# get minimum sensitivity at each probabilities
sensitivities$mean.sensitivity <- apply(sensitivities, 1, mean, na.rm = TRUE)
# add thresholds to data frame
sensitivities$thresholds <- thresholds
# put in a data frame
sensitivities$n_calls <- rowSums(as.data.frame(lapply(sensitiv_l, "[[", which(names(sensitiv_l[[1]]) == "n_calls"))), na.rm = TRUE)
sensitivities$n_calls_prop <- sensitivities$n_calls / max(sensitivities$n_calls)
sensitivities <- sensitivities[!is.infinite(sensitivities$mean.sensitivity), ]
return(sensitivities)
}
# read ext sel tab calls
clls <- readRDS("./output/CALLS_fixed_detections_inquiry_calls.RDS")
# read metadata
metadat <- as.data.frame(read_excel("./data/raw/Proyecto MPI enero 2020_3.xlsx", sheet = "Experimento video coor vuelo"))
# nrow(metadat)
# remove video calibration
# metadat <- metadat[metadat$`tipo de video` !=  "calibracion de video", ]
metadat <- metadat[!is.na(metadat$Audio), ]
# get audio file name from sound files
clls$Audio <- sapply(clls$sound.files, function(x){
# split by _
spl <- strsplit(x, split = "_")[[1]]
# take 3rd
spl <- spl[grep(".wav$", spl)]
# remove .wav
spl <- gsub(".wav", "", spl)
# make it anumber
spl <- as.numeric(spl)
return(spl)
})
# anyNA(clls$Audio)
# nrow(clls)
clls <- clls[clls$Audio %in% metadat$Audio, ]
# add metadata to ext sel table
clls2 <- merge(clls, metadat[!duplicated(metadat$Audio), c("Audio", "tipo de video", "Experimento", "Grupo", "Individuo")])
clls <- fix_extended_selection_table(X = clls2, Y = clls)
# exclude those with obstacles
clls <- clls[clls$Experimento != "Búsqueda refugio con obstaculos", ]
clls$Individuo[clls$Experimento != "vuelo solo"] <- NA
## add 'developer' to packages to be installed from github
x <- c("devtools", "maRce10/warbleR", "readxl", "ranger", "caret", "e1071", "pbapply", "viridis", "ggplot2", "kableExtra", "rlang")
aa <- lapply(x, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  devtools::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
try(require(pkg, character.only = T), silent = T)
})
R.version
